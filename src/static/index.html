<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalPaste.rs</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
    /* Tree view styles */
    .tree-view {
        padding: 0;
        list-style: none;
        user-select: none;
    }
    
    .tree-item {
        margin: 2px 0;
    }
    
    .tree-folder {
        font-weight: 600;
        cursor: pointer;
        padding: 6px 8px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 4px;
        transition: all 0.2s;
    }
    
    .tree-folder:hover {
        background: var(--bg-tertiary);
    }
    
    .tree-folder.drag-over {
        background: rgba(229, 112, 0, 0.2);
        border: 1px dashed var(--accent);
    }
    
    .tree-folder-icon {
        transition: transform 0.2s;
        display: inline-block;
    }
    
    .tree-folder.expanded .tree-folder-icon {
        transform: rotate(90deg);
    }
    
    .tree-contents {
        margin-left: 20px;
        display: none;
        list-style: none;
        padding: 0;
    }
    
    .tree-folder.expanded + .tree-contents {
        display: block;
    }
    
    .tree-paste {
        padding: 4px 8px;
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .tree-paste:hover {
        background: var(--bg-tertiary);
    }
    
    .tree-paste.active {
        background: var(--accent);
        color: white;
    }
    
    .tree-paste.dragging {
        opacity: 0.5;
    }
    
    .paste-date {
        font-size: 11px;
        opacity: 0.6;
        margin-left: auto;
    }
    
    .empty-state {
        padding: 20px;
        text-align: center;
        opacity: 0.5;
        font-style: italic;
    }
    
    #editor {
        width: 100%;
        height: 100%;
        background: transparent;
        color: var(--text-primary);
        border: none;
        outline: none;
        resize: none;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 20px;
    }
    
    .editor-container {
        position: relative;
        background: var(--bg-primary);
    }
    
    .auto-saved {
        color: #3fb950;
        animation: fade-in 0.3s;
    }
    
    @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    </style>
</head>
<body>
    <div id="app">
        <aside class="sidebar">
            <div class="logo"><h1>LocalPaste.rs</h1></div>
            <div class="quick-actions">
                <button id="new-paste" class="btn-primary" title="New Paste (Ctrl+N)">+ New</button>
                <button id="new-folder" class="btn-secondary" title="New Folder">+ Folder</button>
            </div>
            <div class="search-container">
                <input type="text" id="search" placeholder="Search... (Ctrl+K)" />
            </div>
            
            <!-- Single tree view for everything -->
            <div class="pastes" style="flex: 1; overflow-y: auto; padding: 0 8px;">
                <ul id="tree-view" class="tree-view">
                    <!-- Tree will be rendered here -->
                </ul>
            </div>
        </aside>
        <main class="main-content">
            <header class="editor-header">
                <div class="paste-info">
                    <input type="text" id="paste-name" class="paste-name" placeholder="Auto-named..." readonly style="background: transparent; border: none; cursor: text;" />
                    <span class="paste-meta">
                        <span id="paste-language">plain</span> ‚Ä¢ 
                        <span id="paste-date">just now</span> ‚Ä¢ 
                        <span id="char-count">0 chars</span> ‚Ä¢ 
                        <span id="save-status" class="auto-saved" style="display: none;">‚úì saved</span>
                    </span>
                </div>
                <div class="editor-actions">
                    <button id="download-paste" class="btn-icon" title="Download as file">üíæ</button>
                    <button id="delete-paste" class="btn-icon danger" title="Delete (Ctrl+D)">üóëÔ∏è</button>
                </div>
            </header>
            <div id="editor-container" class="editor-container">
                <textarea id="editor"></textarea>
            </div>
            <footer class="status-bar">
                <div class="status-left"><span id="status-message">Ready</span></div>
                <div class="status-right"><span id="cursor-position">Ln 1, Col 1</span></div>
            </footer>
        </main>
    </div>

    <script>
    class LocalPaste {
        constructor() {
            this.currentPaste = null;
            this.pastes = [];
            this.folders = [];
            this.editor = document.getElementById('editor');
            this.saveTimeout = null;
            this.draggedPaste = null;
            this.expandedFolders = new Set(['unfiled']); // Start with unfiled expanded
            
            console.log('LocalPaste.rs: Initializing...');
            this.init();
        }

        async init() {
            try {
                this.bindEvents();
                await this.loadData();
                this.setStatus('Ready');
                console.log('LocalPaste.rs: Initialized');
            } catch (err) {
                console.error('LocalPaste.rs: Init failed:', err);
                this.setStatus('Error: ' + err.message);
            }
        }

        async loadData() {
            await Promise.all([
                this.loadFolders(),
                this.loadPastes()
            ]);
            
            this.renderTree();
            
            // Load first unfiled paste if available
            const unfiledPastes = this.pastes.filter(p => !p.folder_id);
            if (unfiledPastes.length > 0) {
                await this.loadPaste(unfiledPastes[0].id);
            }
        }

        renderTree() {
            const container = document.getElementById('tree-view');
            container.innerHTML = '';
            
            // Group pastes by folder
            const unfiledPastes = this.pastes.filter(p => !p.folder_id);
            const pastesByFolder = {};
            this.pastes.forEach(paste => {
                if (paste.folder_id) {
                    if (!pastesByFolder[paste.folder_id]) {
                        pastesByFolder[paste.folder_id] = [];
                    }
                    pastesByFolder[paste.folder_id].push(paste);
                }
            });
            
            // Render folders first
            this.folders.forEach(folder => {
                const folderItem = document.createElement('li');
                folderItem.className = 'tree-item';
                
                const folderDiv = document.createElement('div');
                folderDiv.className = 'tree-folder';
                if (this.expandedFolders.has(folder.id)) {
                    folderDiv.classList.add('expanded');
                }
                
                folderDiv.innerHTML = `
                    <span class="tree-folder-icon">‚ñ∂</span>
                    üìÅ ${folder.name}
                    <span style="opacity: 0.6; font-size: 12px; margin-left: 4px;">(${pastesByFolder[folder.id]?.length || 0})</span>
                `;
                
                folderDiv.addEventListener('click', () => this.toggleFolder(folder.id));
                this.setupFolderDrop(folderDiv, folder.id);
                
                folderItem.appendChild(folderDiv);
                
                // Folder contents
                const contents = document.createElement('ul');
                contents.className = 'tree-contents';
                
                const folderPastes = pastesByFolder[folder.id] || [];
                if (folderPastes.length === 0) {
                    const emptyLi = document.createElement('li');
                    emptyLi.className = 'empty-state';
                    emptyLi.textContent = 'Empty folder';
                    contents.appendChild(emptyLi);
                } else {
                    folderPastes.forEach(paste => {
                        contents.appendChild(this.createPasteElement(paste));
                    });
                }
                
                folderItem.appendChild(contents);
                container.appendChild(folderItem);
            });
            
            // Render unfiled pastes at the bottom
            if (unfiledPastes.length > 0) {
                const unfiledItem = document.createElement('li');
                unfiledItem.className = 'tree-item';
                
                const unfiledDiv = document.createElement('div');
                unfiledDiv.className = 'tree-folder';
                if (this.expandedFolders.has('unfiled')) {
                    unfiledDiv.classList.add('expanded');
                }
                
                unfiledDiv.innerHTML = `
                    <span class="tree-folder-icon">‚ñ∂</span>
                    üìÑ Unfiled
                    <span style="opacity: 0.6; font-size: 12px; margin-left: 4px;">(${unfiledPastes.length})</span>
                `;
                
                unfiledDiv.addEventListener('click', () => this.toggleFolder('unfiled'));
                this.setupFolderDrop(unfiledDiv, null);
                
                unfiledItem.appendChild(unfiledDiv);
                
                const contents = document.createElement('ul');
                contents.className = 'tree-contents';
                
                unfiledPastes.forEach(paste => {
                    contents.appendChild(this.createPasteElement(paste));
                });
                
                unfiledItem.appendChild(contents);
                container.appendChild(unfiledItem);
            }
        }

        createPasteElement(paste) {
            const li = document.createElement('li');
            li.className = 'tree-paste';
            li.draggable = true;
            li.dataset.pasteId = paste.id;
            
            if (this.currentPaste?.id === paste.id) {
                li.classList.add('active');
            }
            
            const date = new Date(paste.created_at);
            const dateStr = date.toLocaleDateString();
            
            li.innerHTML = `
                ${paste.name}
                <span class="paste-date">${dateStr}</span>
            `;
            
            li.addEventListener('click', () => this.loadPaste(paste.id));
            
            // Drag support
            li.addEventListener('dragstart', (e) => {
                this.draggedPaste = paste.id;
                li.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            li.addEventListener('dragend', () => {
                this.draggedPaste = null;
                li.classList.remove('dragging');
            });
            
            return li;
        }

        toggleFolder(folderId) {
            if (this.expandedFolders.has(folderId)) {
                this.expandedFolders.delete(folderId);
            } else {
                this.expandedFolders.add(folderId);
            }
            this.renderTree();
        }

        setupFolderDrop(element, folderId) {
            element.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                element.classList.add('drag-over');
            });
            
            element.addEventListener('dragleave', (e) => {
                e.stopPropagation();
                element.classList.remove('drag-over');
            });
            
            element.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                element.classList.remove('drag-over');
                
                if (this.draggedPaste) {
                    await this.movePasteToFolder(this.draggedPaste, folderId);
                }
            });
        }

        async movePasteToFolder(pasteId, folderId) {
            try {
                const res = await fetch(`/api/paste/${pasteId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_id: folderId })
                });
                
                if (!res.ok) throw new Error('Failed to move paste');
                
                await this.loadData();
                this.setStatus('Paste moved');
            } catch (err) {
                console.error('Error moving paste:', err);
                this.setStatus('Failed to move paste');
            }
        }

        bindEvents() {
            // Editor events
            this.editor.addEventListener('input', () => {
                this.onEditorChange();
                this.detectLanguage();
            });
            this.editor.addEventListener('keyup', () => this.updateCursorPosition());
            this.editor.addEventListener('click', () => this.updateCursorPosition());
            
            // New paste
            document.getElementById('new-paste').addEventListener('click', () => this.createNewPaste());
            
            // New folder
            document.getElementById('new-folder').addEventListener('click', () => this.createNewFolder());
            
            // Download
            document.getElementById('download-paste').addEventListener('click', () => this.downloadPaste());
            
            // Delete
            document.getElementById('delete-paste').addEventListener('click', () => this.deletePaste());
            
            // Search
            const searchInput = document.getElementById('search');
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => this.searchPastes(e.target.value), 300);
            });
            
            // Name change
            const nameInput = document.getElementById('paste-name');
            nameInput.addEventListener('click', () => {
                nameInput.readOnly = false;
                nameInput.select();
            });
            nameInput.addEventListener('blur', () => {
                nameInput.readOnly = true;
                this.savePaste();
            });
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    nameInput.blur();
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'n':
                            e.preventDefault();
                            this.createNewPaste();
                            break;
                        case 'k':
                            e.preventDefault();
                            searchInput.focus();
                            break;
                        case 'd':
                            e.preventDefault();
                            this.deletePaste();
                            break;
                    }
                }
            });
        }

        detectLanguage() {
            const text = this.editor.value;
            let language = null;
            if (text.includes('function') || text.includes('=>') || text.includes('const ')) language = 'javascript';
            if (text.includes('def ') || text.includes('import ') || text.includes('print(')) language = 'python';
            if (text.includes('fn ') || text.includes('impl ') || text.includes('let ')) language = 'rust';
            if (text.includes('package ') || text.includes('func ')) language = 'go';
            if (text.includes('<html') || text.includes('<div')) language = 'html';
            if (text.includes('{') && text.includes('}') && text.includes(':')) language = 'css';
            if (text.includes('SELECT ') || text.includes('INSERT ')) language = 'sql';
            if (text.includes('#') && text.includes('##')) language = 'markdown';
            document.getElementById('paste-language').textContent = language || 'plain';
        }

        async createNewPaste() {
            try {
                const res = await fetch('/api/paste', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: '' })
                });
                
                if (!res.ok) throw new Error('Failed to create paste');
                
                const paste = await res.json();
                await this.loadData();
                await this.loadPaste(paste.id);
                this.setStatus('New paste created');
                this.editor.focus();
            } catch (err) {
                console.error('Error creating paste:', err);
                this.setStatus('Failed to create paste');
            }
        }

        async createNewFolder() {
            const name = prompt('Folder name:');
            if (!name) return;
            
            try {
                const res = await fetch('/api/folder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                if (!res.ok) throw new Error('Failed to create folder');
                
                await this.loadData();
                this.setStatus('Folder created');
            } catch (err) {
                console.error('Error creating folder:', err);
                this.setStatus('Failed to create folder');
            }
        }

        async loadFolders() {
            try {
                const res = await fetch('/api/folders');
                if (!res.ok) throw new Error('Failed to load folders');
                
                this.folders = await res.json();
            } catch (err) {
                console.error('Error loading folders:', err);
                this.folders = [];
            }
        }

        async savePaste() {
            if (!this.currentPaste) return;
            
            try {
                const content = this.editor.value;
                const name = document.getElementById('paste-name').value || this.currentPaste.name;
                
                const res = await fetch(`/api/paste/${this.currentPaste.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content,
                        name
                    })
                });
                
                if (!res.ok) throw new Error('Failed to save');
                
                this.currentPaste = await res.json();
                
                // Show save indicator
                const saveStatus = document.getElementById('save-status');
                saveStatus.style.display = 'inline';
                setTimeout(() => {
                    saveStatus.style.display = 'none';
                }, 2000);
                
                await this.loadData();
            } catch (err) {
                console.error('Error saving:', err);
                this.setStatus('Failed to save');
            }
        }

        async loadPastes(query = '') {
            try {
                let url = '/api/pastes?limit=100';
                
                if (query) {
                    url = `/api/search?q=${encodeURIComponent(query)}&limit=100`;
                }
                
                const res = await fetch(url);
                if (!res.ok) throw new Error('Failed to load pastes');
                
                this.pastes = await res.json();
            } catch (err) {
                console.error('Error loading pastes:', err);
                this.pastes = [];
            }
        }

        async searchPastes(query) {
            await this.loadPastes(query);
            this.renderTree();
        }

        async loadPaste(id) {
            try {
                const res = await fetch(`/api/paste/${id}`);
                if (!res.ok) throw new Error('Failed to load paste');
                
                const paste = await res.json();
                this.currentPaste = paste;
                
                // Update editor
                this.editor.value = paste.content;
                this.detectLanguage();
                
                // Update UI
                document.getElementById('paste-name').value = paste.name;
                document.getElementById('paste-date').textContent = new Date(paste.updated_at).toLocaleString();
                document.getElementById('char-count').textContent = `${paste.content.length} chars`;
                
                this.renderTree();
                this.updateCursorPosition();
            } catch (err) {
                console.error('Error loading paste:', err);
                this.setStatus('Failed to load paste');
            }
        }

        downloadPaste() {
            if (!this.currentPaste) {
                this.setStatus('No paste to download');
                return;
            }
            
            // Determine file extension based on language
            let ext = 'txt';
            const lang = document.getElementById('paste-language').textContent;
            const langExtMap = {
                'javascript': 'js',
                'python': 'py',
                'rust': 'rs',
                'go': 'go',
                'html': 'html',
                'css': 'css',
                'sql': 'sql',
                'markdown': 'md',
                'json': 'json',
                'yaml': 'yml',
                'toml': 'toml'
            };
            if (langExtMap[lang]) {
                ext = langExtMap[lang];
            }
            
            // Create blob and download
            const blob = new Blob([this.editor.value], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${this.currentPaste.name}.${ext}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.setStatus('Downloaded');
        }

        async deletePaste() {
            if (!this.currentPaste) return;
            
            if (!confirm(`Delete "${this.currentPaste.name}"?`)) return;
            
            try {
                const res = await fetch(`/api/paste/${this.currentPaste.id}`, {
                    method: 'DELETE'
                });
                
                if (!res.ok) throw new Error('Failed to delete');
                
                this.currentPaste = null;
                this.editor.value = '';
                
                await this.loadData();
                
                this.setStatus('Paste deleted');
            } catch (err) {
                console.error('Error deleting:', err);
                this.setStatus('Failed to delete');
            }
        }

        onEditorChange() {
            if (!this.currentPaste) return;
            
            const charCount = this.editor.value.length;
            document.getElementById('char-count').textContent = `${charCount} chars`;
            
            // Auto-save
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => {
                this.savePaste();
            }, 1000);
        }

        updateCursorPosition() {
            const pos = this.editor.selectionStart;
            const text = this.editor.value.substring(0, pos);
            const lines = text.split('\n');
            const line = lines.length;
            const col = lines[lines.length - 1].length + 1;
            
            document.getElementById('cursor-position').textContent = `Ln ${line}, Col ${col}`;
        }

        setStatus(message) {
            const el = document.getElementById('status-message');
            el.textContent = message;
            if (message !== 'Ready') {
                setTimeout(() => {
                    el.textContent = 'Ready';
                }, 3000);
            }
        }
    }

    // Start the app
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new LocalPaste();
    });
    </script>
</body>
</html>