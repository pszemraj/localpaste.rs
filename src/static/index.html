<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalPaste</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div id="app">
        <aside class="sidebar">
            <div class="logo"><h1>LocalPaste</h1></div>
            <div class="quick-actions">
                <button id="new-paste" class="btn-primary" title="New Paste (Ctrl+N)">+ New</button>
                <button id="quick-save" class="btn-secondary" title="Quick Save (Ctrl+S)">Save</button>
            </div>
            <div class="search-container">
                <input type="text" id="search" placeholder="Search... (Ctrl+K)" />
            </div>
            <div class="folders">
                <div class="section-header">
                    <span>Folders</span>
                    <button id="new-folder" class="btn-icon" title="New Folder">+</button>
                </div>
                <ul id="folder-list">
                    <li class="active" data-folder="all">All Pastes</li>
                </ul>
            </div>
            <div class="pastes">
                <div class="section-header"><span>Recent</span></div>
                <ul id="paste-list"></ul>
            </div>
        </aside>
        <main class="main-content">
            <header class="editor-header">
                <div class="paste-info">
                    <input type="text" id="paste-name" class="paste-name" placeholder="untitled" />
                    <select id="paste-folder" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); padding: 4px; border-radius: 4px;">
                        <option value="">No Folder</option>
                    </select>
                    <span class="paste-meta">
                        <span id="paste-language">plain</span> ‚Ä¢ 
                        <span id="paste-date">just now</span> ‚Ä¢ 
                        <span id="char-count">0 chars</span>
                    </span>
                </div>
                <div class="editor-actions">
                    <button id="delete-paste" class="btn-icon danger" title="Delete (Ctrl+D)">üóëÔ∏è</button>
                </div>
            </header>
            <div id="editor-container" class="editor-container">
                <textarea id="editor" style="width: 100%; height: 100%; background: transparent; color: var(--text-primary); border: none; outline: none; resize: none; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 14px; line-height: 1.5; padding: 20px;"></textarea>
            </div>
            <footer class="status-bar">
                <div class="status-left"><span id="status-message">Ready</span></div>
                <div class="status-right"><span id="cursor-position">Ln 1, Col 1</span></div>
            </footer>
        </main>
    </div>

    <script>
    class LocalPaste {
        constructor() {
            this.currentPaste = null;
            this.pastes = [];
            this.folders = [];
            this.editor = document.getElementById('editor');
            this.saveTimeout = null;
            
            console.log('LocalPaste: Initializing...');
            this.init();
        }

        async init() {
            try {
                this.bindEvents();
                await Promise.all([
                    this.loadFolders(),
                    this.loadPastes()
                ]);
                
                if (this.pastes.length > 0) {
                    await this.loadPaste(this.pastes[0].id);
                }
                
                this.setStatus('Ready');
                console.log('LocalPaste: Initialized');
            } catch (err) {
                console.error('LocalPaste: Init failed:', err);
                this.setStatus('Error: ' + err.message);
            }
        }

        bindEvents() {
            // Editor events
            this.editor.addEventListener('input', () => this.onEditorChange());
            this.editor.addEventListener('keyup', () => this.updateCursorPosition());
            this.editor.addEventListener('click', () => this.updateCursorPosition());
            
            // New paste
            document.getElementById('new-paste').addEventListener('click', () => this.createNewPaste());
            
            // Save
            document.getElementById('quick-save').addEventListener('click', () => this.savePaste());
            
            // Delete
            document.getElementById('delete-paste').addEventListener('click', () => this.deletePaste());
            
            // Search
            const searchInput = document.getElementById('search');
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => this.searchPastes(e.target.value), 300);
            });
            
            // Name change
            document.getElementById('paste-name').addEventListener('change', () => this.savePaste());
            
            // Folder change
            document.getElementById('paste-folder').addEventListener('change', () => this.savePaste());
            
            // New folder
            document.getElementById('new-folder').addEventListener('click', () => this.createNewFolder());
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 's':
                            e.preventDefault();
                            this.savePaste();
                            break;
                        case 'n':
                            e.preventDefault();
                            this.createNewPaste();
                            break;
                        case 'k':
                            e.preventDefault();
                            searchInput.focus();
                            break;
                        case 'd':
                            e.preventDefault();
                            this.deletePaste();
                            break;
                    }
                }
            });
        }

        async createNewPaste() {
            try {
                const res = await fetch('/api/paste', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        content: '# New Paste\n\nStart typing...', 
                        name: 'New Paste'
                    })
                });
                
                if (!res.ok) throw new Error('Failed to create paste');
                
                const paste = await res.json();
                await this.loadPastes();
                await this.loadPaste(paste.id);
                this.setStatus('New paste created');
            } catch (err) {
                console.error('Error creating paste:', err);
                this.setStatus('Failed to create paste');
            }
        }

        async createNewFolder() {
            const name = prompt('Folder name:');
            if (!name) return;
            
            try {
                const res = await fetch('/api/folder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                if (!res.ok) throw new Error('Failed to create folder');
                
                await this.loadFolders();
                this.setStatus('Folder created');
            } catch (err) {
                console.error('Error creating folder:', err);
                this.setStatus('Failed to create folder');
            }
        }

        async loadFolders() {
            try {
                const res = await fetch('/api/folders');
                if (!res.ok) throw new Error('Failed to load folders');
                
                this.folders = await res.json();
                this.renderFolders();
            } catch (err) {
                console.error('Error loading folders:', err);
                this.folders = [];
                this.renderFolders();
            }
        }

        renderFolders() {
            const container = document.getElementById('folder-list');
            container.innerHTML = '';
            
            // All Pastes
            const allItem = document.createElement('li');
            allItem.className = 'active';
            allItem.dataset.folder = 'all';
            allItem.textContent = 'All Pastes';
            allItem.addEventListener('click', () => this.selectFolder(null));
            container.appendChild(allItem);
            
            // Folders
            this.folders.forEach(folder => {
                const li = document.createElement('li');
                li.dataset.folderId = folder.id;
                li.textContent = `${folder.name} (${folder.paste_count})`;
                li.addEventListener('click', () => this.selectFolder(folder.id));
                container.appendChild(li);
            });
            
            // Update dropdown
            const select = document.getElementById('paste-folder');
            select.innerHTML = '<option value="">No Folder</option>';
            this.folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = folder.name;
                select.appendChild(option);
            });
        }

        selectFolder(folderId) {
            document.querySelectorAll('#folder-list li').forEach(li => {
                li.classList.remove('active');
            });
            
            if (folderId) {
                const li = document.querySelector(`[data-folder-id="${folderId}"]`);
                if (li) li.classList.add('active');
            } else {
                const li = document.querySelector('[data-folder="all"]');
                if (li) li.classList.add('active');
            }
            
            this.loadPastes('', folderId);
        }

        async savePaste() {
            if (!this.currentPaste) return;
            
            try {
                const content = this.editor.value;
                const name = document.getElementById('paste-name').value || 'untitled';
                const folderId = document.getElementById('paste-folder').value;
                
                const res = await fetch(`/api/paste/${this.currentPaste.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content,
                        name,
                        folder_id: folderId || null
                    })
                });
                
                if (!res.ok) throw new Error('Failed to save');
                
                this.currentPaste = await res.json();
                this.setStatus('Saved');
                await this.loadPastes();
                await this.loadFolders(); // Refresh folder counts
            } catch (err) {
                console.error('Error saving:', err);
                this.setStatus('Failed to save');
            }
        }

        async loadPastes(query = '', folderId = null) {
            try {
                let url = '/api/pastes?limit=50';
                
                if (query) {
                    url = `/api/search?q=${encodeURIComponent(query)}&limit=50`;
                } else if (folderId) {
                    url += `&folder_id=${folderId}`;
                }
                
                const res = await fetch(url);
                if (!res.ok) throw new Error('Failed to load pastes');
                
                this.pastes = await res.json();
                this.renderPasteList();
            } catch (err) {
                console.error('Error loading pastes:', err);
                this.pastes = [];
                this.renderPasteList();
            }
        }

        searchPastes(query) {
            this.loadPastes(query);
        }

        renderPasteList() {
            const container = document.getElementById('paste-list');
            container.innerHTML = '';
            
            if (this.pastes.length === 0) {
                container.innerHTML = '<li style="opacity: 0.5; font-style: italic;">No pastes</li>';
                return;
            }
            
            this.pastes.forEach(paste => {
                const li = document.createElement('li');
                li.dataset.pasteId = paste.id;
                if (this.currentPaste?.id === paste.id) {
                    li.classList.add('active');
                }
                li.textContent = paste.name;
                li.addEventListener('click', () => this.loadPaste(paste.id));
                container.appendChild(li);
            });
        }

        async loadPaste(id) {
            try {
                const res = await fetch(`/api/paste/${id}`);
                if (!res.ok) throw new Error('Failed to load paste');
                
                const paste = await res.json();
                this.currentPaste = paste;
                
                // Update editor
                this.editor.value = paste.content;
                
                // Update UI
                document.getElementById('paste-name').value = paste.name;
                document.getElementById('paste-folder').value = paste.folder_id || '';
                document.getElementById('paste-language').textContent = paste.language || 'plain';
                document.getElementById('paste-date').textContent = new Date(paste.updated_at).toLocaleString();
                document.getElementById('char-count').textContent = `${paste.content.length} chars`;
                
                this.renderPasteList();
                this.updateCursorPosition();
            } catch (err) {
                console.error('Error loading paste:', err);
                this.setStatus('Failed to load paste');
            }
        }

        async deletePaste() {
            if (!this.currentPaste) return;
            
            if (!confirm(`Delete "${this.currentPaste.name}"?`)) return;
            
            try {
                const res = await fetch(`/api/paste/${this.currentPaste.id}`, {
                    method: 'DELETE'
                });
                
                if (!res.ok) throw new Error('Failed to delete');
                
                this.currentPaste = null;
                this.editor.value = '';
                
                await this.loadPastes();
                await this.loadFolders(); // Refresh folder counts
                
                if (this.pastes.length > 0) {
                    await this.loadPaste(this.pastes[0].id);
                }
                
                this.setStatus('Paste deleted');
            } catch (err) {
                console.error('Error deleting:', err);
                this.setStatus('Failed to delete');
            }
        }

        onEditorChange() {
            if (!this.currentPaste) return;
            
            const charCount = this.editor.value.length;
            document.getElementById('char-count').textContent = `${charCount} chars`;
            
            // Auto-save
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => {
                this.savePaste();
            }, 2000);
        }

        updateCursorPosition() {
            const pos = this.editor.selectionStart;
            const text = this.editor.value.substring(0, pos);
            const lines = text.split('\n');
            const line = lines.length;
            const col = lines[lines.length - 1].length + 1;
            
            document.getElementById('cursor-position').textContent = `Ln ${line}, Col ${col}`;
        }

        setStatus(message) {
            const el = document.getElementById('status-message');
            el.textContent = message;
            if (message !== 'Ready') {
                setTimeout(() => {
                    el.textContent = 'Ready';
                }, 3000);
            }
        }
    }

    // Start the app
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new LocalPaste();
    });
    </script>
</body>
</html>