name: release-gui

on:
  push:
    tags:
      - v*
  workflow_dispatch:
    inputs:
      tag:
        description: Existing tag to release (for example v0.4.3)
        required: true
        type: string
      dry_run:
        description: Build/test only (skip publish job)
        required: false
        default: false
        type: boolean

permissions:
  contents: write

concurrency:
  group: release-gui-${{ github.event_name }}-${{ github.ref_name || github.event.inputs.tag || github.run_id }}
  cancel-in-progress: false

jobs:
  resolve_tag:
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    outputs:
      resolved_tag: ${{ steps.resolve.outputs.resolved_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve release tag
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            TAG="${{ github.event.inputs.tag }}"
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          if [[ -z "${TAG}" ]]; then
            echo "release tag cannot be empty" >&2
            exit 1
          fi

          if [[ "${TAG}" != v* ]]; then
            echo "release tag must start with 'v' (got: ${TAG})" >&2
            exit 1
          fi

          git fetch --force --tags origin
          git rev-parse "refs/tags/${TAG}" >/dev/null

          echo "resolved_tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "resolved tag: ${TAG}"

      - name: Checkout release tag source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/tags/${{ steps.resolve.outputs.resolved_tag }}

      - name: Validate workspace version matches tag
        shell: bash
        run: |
          set -euo pipefail
          WORKSPACE_VERSION="$(
            awk '
              $0 == "[workspace.package]" { in_workspace = 1; next }
              /^\[/ { if (in_workspace) exit }
              in_workspace && $1 == "version" {
                gsub(/"/, "", $3)
                print $3
                exit
              }
            ' Cargo.toml
          )"
          TAG_VERSION="${{ steps.resolve.outputs.resolved_tag }}"
          TAG_VERSION="${TAG_VERSION#v}"

          if [[ -z "${WORKSPACE_VERSION}" ]]; then
            echo "failed to read [workspace.package].version from Cargo.toml" >&2
            exit 1
          fi

          if [[ "${WORKSPACE_VERSION}" != "${TAG_VERSION}" ]]; then
            echo "tag/version mismatch: tag=${TAG_VERSION} workspace=${WORKSPACE_VERSION}" >&2
            exit 1
          fi

  smoke:
    needs: resolve_tag
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    env:
      RESOLVED_TAG: ${{ needs.resolve_tag.outputs.resolved_tag }}
    steps:
      - name: Checkout release tag source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/tags/${{ needs.resolve_tag.outputs.resolved_tag }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.89.0

      - name: Cache Rust build artifacts
        uses: swatinem/rust-cache@v2

      - name: Build smoke binaries
        shell: bash
        run: |
          set -euo pipefail
          cargo build -p localpaste_server --bin localpaste
          cargo build -p localpaste_cli --bin lpaste

      - name: Smoke test (server + CLI CRUD + restart persistence)
        shell: bash
        run: |
          set -euo pipefail
          PORT="$(python3 -c 'import socket; s=socket.socket(); s.bind(("127.0.0.1", 0)); print(s.getsockname()[1]); s.close()')"
          export PORT
          export DB_PATH="${GITHUB_WORKSPACE}/.tmp/release-smoke-${GITHUB_RUN_ID}"
          export RUST_LOG=info
          export LP_SERVER="http://127.0.0.1:${PORT}"
          mkdir -p "${DB_PATH}"

          wait_for_localpaste_ready() {
            local max_attempts=120
            local attempt=1
            local health_url="${LP_SERVER}/api/pastes/meta?limit=1"
            while (( attempt <= max_attempts )); do
              if curl -fsS --connect-timeout 1 --max-time 2 "${health_url}" >/dev/null 2>&1; then
                return 0
              fi
              if [[ -n "${SERVER_PID:-}" ]] && ! kill -0 "${SERVER_PID}" 2>/dev/null; then
                echo "localpaste exited before readiness probe succeeded" >&2
                return 1
              fi
              sleep 1
              attempt=$(( attempt + 1 ))
            done
            echo "localpaste did not become ready after ${max_attempts}s" >&2
            return 1
          }

          start_server() {
            ./target/debug/localpaste &
            SERVER_PID=$!
            wait_for_localpaste_ready
          }

          stop_server() {
            if [[ -n "${SERVER_PID:-}" ]]; then
              kill "${SERVER_PID}" 2>/dev/null || true
              wait "${SERVER_PID}" 2>/dev/null || true
              unset SERVER_PID
            fi
          }

          cleanup() {
            stop_server
            rm -rf "${DB_PATH}"
          }
          trap cleanup EXIT

          start_server

          echo "hello from release smoke" | ./target/debug/lpaste --timing new --name "release-smoke"
          ./target/debug/lpaste --timing list --limit 5
          ./target/debug/lpaste --timing search "release-smoke"
          ID="$(./target/debug/lpaste list --limit 1 | awk '{print $1}')"
          ./target/debug/lpaste --timing get "${ID}"
          ./target/debug/lpaste --timing delete "${ID}"

          echo "persist me" | ./target/debug/lpaste --timing new --name "release-persist"
          PERSIST_ID="$(./target/debug/lpaste list --limit 1 | awk '{print $1}')"

          stop_server

          start_server
          ./target/debug/lpaste --timing get "${PERSIST_ID}"

  build_package:
    needs:
      - resolve_tag
      - smoke
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            asset_suffix: windows-x86_64
            packager_config: packaging/windows/packager.json
          - os: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            asset_suffix: linux-x86_64
            packager_config: packaging/linux/packager.json
          - os: macos-14
            target: aarch64-apple-darwin
            asset_suffix: macos-aarch64
            packager_config: packaging/macos/packager.json
    runs-on: ${{ matrix.os }}
    env:
      RESOLVED_TAG: ${{ needs.resolve_tag.outputs.resolved_tag }}
    steps:
      - name: Checkout workflow commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Sync source tree to release tag
        shell: bash
        run: |
          set -euo pipefail
          git fetch --force --tags origin
          git checkout "refs/tags/${RESOLVED_TAG}" -- \
            Cargo.toml \
            Cargo.lock \
            rust-toolchain.toml \
            crates \
            assets \
            LICENSE

          if git ls-tree -d --name-only "refs/tags/${RESOLVED_TAG}" packaging | grep -q '^packaging$'; then
            git checkout "refs/tags/${RESOLVED_TAG}" -- packaging
          else
            echo "packaging/ not present in tag ${RESOLVED_TAG}; using workflow-ref packaging configs"
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.89.0
          targets: ${{ matrix.target }}

      - name: Cache Rust build artifacts
        uses: swatinem/rust-cache@v2
        with:
          key: release-gui-${{ matrix.target }}

      - name: Install Linux build dependencies
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            patchelf \
            libfuse2

      - name: Install WiX Toolset
        if: runner.os == 'Windows'
        shell: pwsh
        run: choco install wixtoolset -y --no-progress

      - name: Install cargo-packager
        run: cargo install cargo-packager --version 0.11.8 --locked

      - name: Build GUI release binary
        run: cargo build -p localpaste_gui --bin localpaste-gui --release --target ${{ matrix.target }}

      - name: Generate macOS icns icon
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          ICON_SRC="assets/icons/desktop_icon.png"
          ICONSET_DIR="dist/macos-icon.iconset"
          ICON_DST="assets/icons/desktop_icon.icns"

          if [[ ! -f "${ICON_SRC}" ]]; then
            echo "missing icon source: ${ICON_SRC}" >&2
            exit 1
          fi

          rm -rf "${ICONSET_DIR}"
          mkdir -p "${ICONSET_DIR}"

          sips -z 16 16 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_16x16.png" >/dev/null
          sips -z 32 32 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_16x16@2x.png" >/dev/null
          sips -z 32 32 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_32x32.png" >/dev/null
          sips -z 64 64 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_32x32@2x.png" >/dev/null
          sips -z 128 128 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_128x128.png" >/dev/null
          sips -z 256 256 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_128x128@2x.png" >/dev/null
          sips -z 256 256 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_256x256.png" >/dev/null
          sips -z 512 512 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_256x256@2x.png" >/dev/null
          sips -z 512 512 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_512x512.png" >/dev/null
          sips -z 1024 1024 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_512x512@2x.png" >/dev/null

          iconutil -c icns "${ICONSET_DIR}" -o "${ICON_DST}"

          if [[ ! -s "${ICON_DST}" ]]; then
            echo "failed to generate icns icon: ${ICON_DST}" >&2
            exit 1
          fi

      - name: Prepare packager config and staged runtime
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/release_gui_prepare.py \
            --tag "${{ env.RESOLVED_TAG }}" \
            --target "${{ matrix.target }}" \
            --asset-suffix "${{ matrix.asset_suffix }}" \
            --packager-config "${{ matrix.packager_config }}" \
            --runner-os "${{ runner.os }}"

      - name: Build installer packages
        run: python -c "import os, subprocess; subprocess.run(['cargo', 'packager', '--config', os.environ['PACKAGER_CONFIG_PATH']], check=True)"

      - name: Collect release assets
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/release_gui_collect.py \
            --tag "${{ env.RESOLVED_TAG }}" \
            --asset-suffix "${{ matrix.asset_suffix }}" \
            --runner-os "${{ runner.os }}"

      - name: Upload release assets
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.asset_suffix }}
          path: dist/release/${{ matrix.asset_suffix }}/*
          if-no-files-found: error
          retention-days: 1

  publish:
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.dry_run != 'true'
    needs:
      - resolve_tag
      - build_package
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    steps:
      - name: Download packaged assets
        uses: actions/download-artifact@v4
        with:
          pattern: release-assets-*
          path: dist/release-assets
          merge-multiple: true

      - name: Generate checksums
        shell: bash
        run: |
          set -euo pipefail
          cd dist/release-assets
          sha256sum localpaste-* > checksums.sha256

      - name: Publish release assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.resolve_tag.outputs.resolved_tag }}
          name: LocalPaste ${{ needs.resolve_tag.outputs.resolved_tag }}
          generate_release_notes: true
          overwrite_files: true
          fail_on_unmatched_files: true
          files: |
            dist/release-assets/localpaste-*
            dist/release-assets/checksums.sha256
