name: verify-gui-packaging
on:
  workflow_dispatch:
    inputs:
      tag:
        description: Optional tag-like version string used for packaging metadata (for example vX.Y.Z). If empty, derives from workspace version.
        required: false
        type: string
permissions:
  contents: read
concurrency:
  group: verify-gui-packaging-${{ github.ref_name }}-${{ github.run_id }}
  cancel-in-progress: false
jobs:
  macos-package-verify:
    runs-on: macos-14
    timeout-minutes: 90
    env:
      VERIFY_TAG_INPUT: ${{ github.event.inputs.tag }}
      TARGET: aarch64-apple-darwin
      ASSET_SUFFIX: macos-aarch64
      PACKAGER_CONFIG: packaging/macos/packager.json
    steps:
      - name: Checkout workflow ref
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0
      - name: Resolve verify tag
        shell: bash
        run: |
          set -euo pipefail
          RAW_TAG="$(printf '%s' "${VERIFY_TAG_INPUT:-}" | xargs)"
          if [[ -n "${RAW_TAG}" ]]; then
            VERIFY_TAG="${RAW_TAG}"
            SOURCE_LABEL="workflow input"
          else
            WORKSPACE_VERSION="$(bash .github/scripts/workspace_version.sh)"
            VERIFY_TAG="v${WORKSPACE_VERSION}"
            SOURCE_LABEL="workspace version"
          fi

          if [[ "${VERIFY_TAG}" != v* ]]; then
            echo "VERIFY_TAG must start with 'v' (got: ${VERIFY_TAG})" >&2
            exit 1
          fi

          echo "VERIFY_TAG=${VERIFY_TAG}" >> "$GITHUB_ENV"
          {
            echo "### Verify tag"
            echo
            echo "Using ${SOURCE_LABEL}: ${VERIFY_TAG}"
          } >> "$GITHUB_STEP_SUMMARY"
      - name: Set up Python
        uses: actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b  # v5.3.0
        with:
          python-version: "3.11"
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@efa25f7f19611383d5b0ccf2d1c8914531636bf9  # master @ 2026-02-23
        with:
          toolchain: 1.89.0
          targets: ${{ env.TARGET }}
      - name: Cache Rust build artifacts
        uses: swatinem/rust-cache@aa7c1c80a07a27a84c0aa76d0cef0aad3830e330  # v2.7.8
        with:
          key: verify-gui-packaging-${{ env.TARGET }}
      - name: Workspace check
        shell: bash
        run: |
          set -euo pipefail
          cargo check --workspace --all-targets --all-features
      - name: GUI test suite
        shell: bash
        run: |
          set -euo pipefail
          cargo test -p localpaste_gui
      - name: Determine macOS signing/notarization availability
        id: mac_signing
        shell: bash
        env:
          APPLE_SIGNING_CERT_BASE64: ${{ secrets.APPLE_SIGNING_CERT_BASE64 }}
          APPLE_SIGNING_CERT_PASSWORD: ${{ secrets.APPLE_SIGNING_CERT_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          missing=()
          required=(
            APPLE_SIGNING_CERT_BASE64
            APPLE_SIGNING_CERT_PASSWORD
            APPLE_SIGNING_IDENTITY
            APPLE_ID
            APPLE_APP_SPECIFIC_PASSWORD
            APPLE_TEAM_ID
          )
          for key in "${required[@]}"; do
            if [[ -z "${!key:-}" ]]; then
              missing+=("${key}")
            fi
          done

          if [[ "${#missing[@]}" -gt 0 ]]; then
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "missing=$(printf '%s ' "${missing[@]}" | sed 's/[[:space:]]*$//')" >> "$GITHUB_OUTPUT"
            {
              echo "### macOS signing/notarization skipped"
              echo
              echo "Missing secrets: $(printf '%s, ' "${missing[@]}" | sed 's/, $//')"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            echo "missing=" >> "$GITHUB_OUTPUT"
          fi
      - name: Install cargo-packager
        run: cargo install cargo-packager --version 0.11.8 --locked
      - name: Build GUI release binary
        run: cargo build -p localpaste_gui --bin localpaste-gui --release --target ${{ env.TARGET }}
      - name: Generate macOS icns icon
        shell: bash
        run: |
          set -euo pipefail
          ICON_SRC="assets/icons/desktop_icon.png"
          ICONSET_DIR="dist/macos-icon.iconset"
          ICON_DST="assets/icons/desktop_icon.icns"

          if [[ ! -f "${ICON_SRC}" ]]; then
            echo "missing icon source: ${ICON_SRC}" >&2
            exit 1
          fi

          rm -rf "${ICONSET_DIR}"
          mkdir -p "${ICONSET_DIR}"

          sips -z 16 16 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_16x16.png" >/dev/null
          sips -z 32 32 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_16x16@2x.png" >/dev/null
          sips -z 32 32 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_32x32.png" >/dev/null
          sips -z 64 64 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_32x32@2x.png" >/dev/null
          sips -z 128 128 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_128x128.png" >/dev/null
          sips -z 256 256 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_128x128@2x.png" >/dev/null
          sips -z 256 256 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_256x256.png" >/dev/null
          sips -z 512 512 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_256x256@2x.png" >/dev/null
          sips -z 512 512 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_512x512.png" >/dev/null
          sips -z 1024 1024 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_512x512@2x.png" >/dev/null

          iconutil -c icns "${ICONSET_DIR}" -o "${ICON_DST}"

          if [[ ! -s "${ICON_DST}" ]]; then
            echo "failed to generate icns icon: ${ICON_DST}" >&2
            exit 1
          fi
      - name: Prepare packager config and staged runtime
        shell: bash
        run: |
          set -euo pipefail
          prepare_args=(
            --tag "${VERIFY_TAG}"
            --target "${TARGET}"
            --asset-suffix "${ASSET_SUFFIX}"
            --packager-config "${PACKAGER_CONFIG}"
            --runner-os "macOS"
          )
          if python .github/scripts/release_gui_prepare.py --help 2>&1 | grep -q -- "--expected-wix-major"; then
            prepare_args+=(--expected-wix-major 3)
          else
            echo "release_gui_prepare.py does not support --expected-wix-major; skipping explicit WiX major assertion"
          fi
          python .github/scripts/release_gui_prepare.py "${prepare_args[@]}"
      - name: Build installer packages
        run: python -c "import os, subprocess; subprocess.run(['cargo', 'packager', '--config', os.environ['PACKAGER_CONFIG_PATH']], check=True)"
      - name: Sign, notarize, and verify macOS artifacts
        if: steps.mac_signing.outputs.enabled == 'true'
        shell: bash
        env:
          APPLE_SIGNING_CERT_BASE64: ${{ secrets.APPLE_SIGNING_CERT_BASE64 }}
          APPLE_SIGNING_CERT_PASSWORD: ${{ secrets.APPLE_SIGNING_CERT_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${RUNNER_TEMP}/localpaste-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"
          CERT_PATH="${RUNNER_TEMP}/localpaste-signing.p12"
          PACKAGER_DIR="dist/packager/${ASSET_SUFFIX}"

          echo "${APPLE_SIGNING_CERT_BASE64}" | base64 --decode > "${CERT_PATH}"
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security set-keychain-settings -lut 21600 "${KEYCHAIN_PATH}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security list-keychains -d user -s "${KEYCHAIN_PATH}"
          security import "${CERT_PATH}" -k "${KEYCHAIN_PATH}" -P "${APPLE_SIGNING_CERT_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"

          APP_BUNDLE="$(find "${PACKAGER_DIR}" -maxdepth 4 -type d -name '*.app' | head -n 1)"
          DMG_PATH="$(find "${PACKAGER_DIR}" -maxdepth 4 -type f -name '*.dmg' | head -n 1)"
          if [[ -z "${APP_BUNDLE}" || -z "${DMG_PATH}" ]]; then
            echo "failed to find .app and .dmg under ${PACKAGER_DIR}" >&2
            exit 1
          fi

          codesign --force --deep --options runtime --timestamp --sign "${APPLE_SIGNING_IDENTITY}" "${APP_BUNDLE}"
          codesign --force --timestamp --sign "${APPLE_SIGNING_IDENTITY}" "${DMG_PATH}"

          xcrun notarytool submit "${DMG_PATH}" \
            --apple-id "${APPLE_ID}" \
            --password "${APPLE_APP_SPECIFIC_PASSWORD}" \
            --team-id "${APPLE_TEAM_ID}" \
            --wait

          xcrun stapler staple "${APP_BUNDLE}"
          xcrun stapler staple "${DMG_PATH}"
          spctl --assess --type open --verbose=4 "${DMG_PATH}"
      - name: Verify signed app bundle inside DMG
        if: steps.mac_signing.outputs.enabled == 'true'
        shell: bash
        run: |
          set -euo pipefail
          PACKAGER_DIR="dist/packager/${ASSET_SUFFIX}"
          DMG_PATH="$(find "${PACKAGER_DIR}" -maxdepth 4 -type f -name '*.dmg' | head -n 1)"
          if [[ -z "${DMG_PATH}" ]]; then
            echo "failed to find .dmg under ${PACKAGER_DIR}" >&2
            exit 1
          fi

          MOUNT_POINT="$(mktemp -d)"
          cleanup() {
            hdiutil detach "${MOUNT_POINT}" >/dev/null 2>&1 || true
            rm -rf "${MOUNT_POINT}"
          }
          trap cleanup EXIT

          hdiutil attach "${DMG_PATH}" -mountpoint "${MOUNT_POINT}" -nobrowse -quiet
          MOUNTED_APP="$(find "${MOUNT_POINT}" -maxdepth 3 -type d -name '*.app' | head -n 1)"
          if [[ -z "${MOUNTED_APP}" ]]; then
            echo "failed to find .app inside mounted DMG ${DMG_PATH}" >&2
            exit 1
          fi

          codesign --verify --deep --strict --verbose=2 "${MOUNTED_APP}"
          spctl --assess --type execute --verbose=4 "${MOUNTED_APP}"
      - name: Verify macOS DMG usability
        shell: bash
        run: |
          set -euo pipefail
          PACKAGER_DIR="dist/packager/${ASSET_SUFFIX}"
          DMG_PATH="$(find "${PACKAGER_DIR}" -maxdepth 4 -type f -name '*.dmg' | head -n 1)"
          if [[ -z "${DMG_PATH}" ]]; then
            echo "failed to find .dmg under ${PACKAGER_DIR}" >&2
            exit 1
          fi

          hdiutil verify "${DMG_PATH}"
          hdiutil imageinfo "${DMG_PATH}" > /tmp/localpaste-dmg-imageinfo.txt
          if ! grep -Eq "Format:\s+UD" /tmp/localpaste-dmg-imageinfo.txt; then
            echo "unexpected DMG format reported by hdiutil imageinfo" >&2
            cat /tmp/localpaste-dmg-imageinfo.txt >&2
            exit 1
          fi
      - name: Collect release assets
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/release_gui_collect.py \
            --tag "${VERIFY_TAG}" \
            --asset-suffix "${ASSET_SUFFIX}" \
            --runner-os "macOS"
      - name: Upload macOS verify artifacts
        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1  # v4.6.1
        with:
          name: verify-gui-packaging-${{ env.ASSET_SUFFIX }}-${{ github.run_id }}
          path: dist/release/${{ env.ASSET_SUFFIX }}/*
          if-no-files-found: error
          retention-days: 7
