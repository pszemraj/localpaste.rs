name: verify-gui-packaging

on:
  workflow_dispatch:
    inputs:
      tag:
        description: Optional tag-like version string used for packaging metadata (for example vX.Y.Z). If empty, derives from workspace version.
        required: false
        type: string

permissions:
  contents: read

concurrency:
  group: verify-gui-packaging-${{ github.ref_name }}-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  macos-package-verify:
    runs-on: macos-14
    timeout-minutes: 90
    env:
      VERIFY_TAG_INPUT: ${{ github.event.inputs.tag }}
      TARGET: aarch64-apple-darwin
      ASSET_SUFFIX: macos-aarch64
      PACKAGER_CONFIG: packaging/macos/packager.json
    steps:
      - name: Checkout workflow ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve verify tag
        shell: bash
        run: |
          set -euo pipefail
          RAW_TAG="$(printf '%s' "${VERIFY_TAG_INPUT:-}" | xargs)"
          if [[ -n "${RAW_TAG}" ]]; then
            VERIFY_TAG="${RAW_TAG}"
            SOURCE_LABEL="workflow input"
          else
            WORKSPACE_VERSION="$(
              awk '
                $0 == "[workspace.package]" { in_workspace = 1; next }
                /^\[/ { if (in_workspace) exit }
                in_workspace && $1 == "version" {
                  gsub(/"/, "", $3)
                  print $3
                  exit
                }
              ' Cargo.toml
            )"
            if [[ -z "${WORKSPACE_VERSION}" ]]; then
              echo "failed to read [workspace.package].version from Cargo.toml" >&2
              exit 1
            fi
            VERIFY_TAG="v${WORKSPACE_VERSION}"
            SOURCE_LABEL="workspace version"
          fi

          if [[ "${VERIFY_TAG}" != v* ]]; then
            echo "VERIFY_TAG must start with 'v' (got: ${VERIFY_TAG})" >&2
            exit 1
          fi

          echo "VERIFY_TAG=${VERIFY_TAG}" >> "$GITHUB_ENV"
          {
            echo "### Verify tag"
            echo
            echo "Using ${SOURCE_LABEL}: ${VERIFY_TAG}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.89.0
          targets: ${{ env.TARGET }}

      - name: Cache Rust build artifacts
        uses: swatinem/rust-cache@v2
        with:
          key: verify-gui-packaging-${{ env.TARGET }}

      - name: Workspace check
        shell: bash
        run: |
          set -euo pipefail
          cargo check --workspace --all-targets --all-features

      - name: GUI test suite
        shell: bash
        run: |
          set -euo pipefail
          cargo test -p localpaste_gui

      - name: Determine macOS signing/notarization availability
        id: mac_signing
        shell: bash
        env:
          APPLE_SIGNING_CERT_BASE64: ${{ secrets.APPLE_SIGNING_CERT_BASE64 }}
          APPLE_SIGNING_CERT_PASSWORD: ${{ secrets.APPLE_SIGNING_CERT_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          missing=()
          required=(
            APPLE_SIGNING_CERT_BASE64
            APPLE_SIGNING_CERT_PASSWORD
            APPLE_SIGNING_IDENTITY
            APPLE_ID
            APPLE_APP_SPECIFIC_PASSWORD
            APPLE_TEAM_ID
          )
          for key in "${required[@]}"; do
            if [[ -z "${!key:-}" ]]; then
              missing+=("${key}")
            fi
          done

          if [[ "${#missing[@]}" -gt 0 ]]; then
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "missing=$(printf '%s ' "${missing[@]}" | sed 's/[[:space:]]*$//')" >> "$GITHUB_OUTPUT"
            {
              echo "### macOS signing/notarization skipped"
              echo
              echo "Missing secrets: $(printf '%s, ' "${missing[@]}" | sed 's/, $//')"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            echo "missing=" >> "$GITHUB_OUTPUT"
          fi

      - name: Install cargo-packager
        run: cargo install cargo-packager --version 0.11.8 --locked

      - name: Build GUI release binary
        run: cargo build -p localpaste_gui --bin localpaste-gui --release --target ${{ env.TARGET }}

      - name: Generate macOS icns icon
        shell: bash
        run: |
          set -euo pipefail
          ICON_SRC="assets/icons/desktop_icon.png"
          ICONSET_DIR="dist/macos-icon.iconset"
          ICON_DST="assets/icons/desktop_icon.icns"

          if [[ ! -f "${ICON_SRC}" ]]; then
            echo "missing icon source: ${ICON_SRC}" >&2
            exit 1
          fi

          rm -rf "${ICONSET_DIR}"
          mkdir -p "${ICONSET_DIR}"

          sips -z 16 16 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_16x16.png" >/dev/null
          sips -z 32 32 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_16x16@2x.png" >/dev/null
          sips -z 32 32 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_32x32.png" >/dev/null
          sips -z 64 64 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_32x32@2x.png" >/dev/null
          sips -z 128 128 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_128x128.png" >/dev/null
          sips -z 256 256 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_128x128@2x.png" >/dev/null
          sips -z 256 256 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_256x256.png" >/dev/null
          sips -z 512 512 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_256x256@2x.png" >/dev/null
          sips -z 512 512 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_512x512.png" >/dev/null
          sips -z 1024 1024 "${ICON_SRC}" --out "${ICONSET_DIR}/icon_512x512@2x.png" >/dev/null

          iconutil -c icns "${ICONSET_DIR}" -o "${ICON_DST}"

          if [[ ! -s "${ICON_DST}" ]]; then
            echo "failed to generate icns icon: ${ICON_DST}" >&2
            exit 1
          fi

      - name: Prepare packager config and staged runtime
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/release_gui_prepare.py \
            --tag "${VERIFY_TAG}" \
            --target "${TARGET}" \
            --asset-suffix "${ASSET_SUFFIX}" \
            --packager-config "${PACKAGER_CONFIG}" \
            --runner-os "macOS"

      - name: Build installer packages
        run: python -c "import os, subprocess; subprocess.run(['cargo', 'packager', '--config', os.environ['PACKAGER_CONFIG_PATH']], check=True)"

      - name: Sign, notarize, and verify macOS artifacts
        if: steps.mac_signing.outputs.enabled == 'true'
        shell: bash
        env:
          APPLE_SIGNING_CERT_BASE64: ${{ secrets.APPLE_SIGNING_CERT_BASE64 }}
          APPLE_SIGNING_CERT_PASSWORD: ${{ secrets.APPLE_SIGNING_CERT_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${RUNNER_TEMP}/localpaste-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"
          CERT_PATH="${RUNNER_TEMP}/localpaste-signing.p12"
          PACKAGER_DIR="dist/packager/${ASSET_SUFFIX}"

          echo "${APPLE_SIGNING_CERT_BASE64}" | base64 --decode > "${CERT_PATH}"
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security set-keychain-settings -lut 21600 "${KEYCHAIN_PATH}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security list-keychains -d user -s "${KEYCHAIN_PATH}"
          security import "${CERT_PATH}" -k "${KEYCHAIN_PATH}" -P "${APPLE_SIGNING_CERT_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"

          APP_BUNDLE="$(find "${PACKAGER_DIR}" -maxdepth 4 -type d -name '*.app' | head -n 1)"
          DMG_PATH="$(find "${PACKAGER_DIR}" -maxdepth 4 -type f -name '*.dmg' | head -n 1)"
          if [[ -z "${APP_BUNDLE}" || -z "${DMG_PATH}" ]]; then
            echo "failed to find .app and .dmg under ${PACKAGER_DIR}" >&2
            exit 1
          fi

          codesign --force --deep --options runtime --timestamp --sign "${APPLE_SIGNING_IDENTITY}" "${APP_BUNDLE}"
          codesign --force --timestamp --sign "${APPLE_SIGNING_IDENTITY}" "${DMG_PATH}"

          xcrun notarytool submit "${DMG_PATH}" \
            --apple-id "${APPLE_ID}" \
            --password "${APPLE_APP_SPECIFIC_PASSWORD}" \
            --team-id "${APPLE_TEAM_ID}" \
            --wait

          xcrun stapler staple "${APP_BUNDLE}"
          xcrun stapler staple "${DMG_PATH}"
          spctl --assess --type open --verbose=4 "${DMG_PATH}"

      - name: Collect release assets
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/release_gui_collect.py \
            --tag "${VERIFY_TAG}" \
            --asset-suffix "${ASSET_SUFFIX}" \
            --runner-os "macOS"

      - name: Upload macOS verify artifacts
        uses: actions/upload-artifact@v4
        with:
          name: verify-gui-packaging-${{ env.ASSET_SUFFIX }}-${{ github.run_id }}
          path: dist/release/${{ env.ASSET_SUFFIX }}/*
          if-no-files-found: error
          retention-days: 7
